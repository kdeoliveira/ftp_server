<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ftp.tcp.client API documentation</title>
<meta name="description" content="TCP socket interface representing FTP client" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ftp.tcp.client</code></h1>
</header>
<section id="section-intro">
<p>TCP socket interface representing FTP client</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
TCP socket interface representing FTP client
&#34;&#34;&#34;

import socket as sok
import sys
from threading import Thread, local
from types import FunctionType
from typing import Callable, List, Optional, Tuple
from unittest import result
from ftp.parser.message import Message, Util

from ftp.parser.message_type import MessageType, MethodType, RequestType, ResponseType

import signal




class TcpClient():
    _DEFAULT_PORT = 1025
    _MAX_BUFFER = 512

    def __init__(self, ip_addr, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        TCP Client interface that creates a new socket given the ip address provided for FTP communication

        Parameters
        ---
        ip_addr: str
            IP address which the TCP service would be listening to
        -p: int
            port value which socket will bind its connection
        -a: str
            new IP address that TCP service will be using
        
        &#34;&#34;&#34;
        self.thread = None
        self.socket = sok.socket(sok.AF_INET, sok.SOCK_STREAM)
        for k,v in kwargs.items():
            if &#34;-p&#34; in k:
                self._DEFAULT_PORT = int(v)
            elif &#34;-a&#34; in k:
                ip_addr = v
        self.ip_address = ip_addr
        self._is_connected = False
        self.create_message_functions : List[Tuple[MethodType, FunctionType] ] = []
        self.on_response_functions: List[Tuple[MethodType, FunctionType]] = []

        signal.signal(signal.SIGINT, self.handler)


    def connect(self):
        &#34;&#34;&#34;
        Creates a TCP socket bounded to the given IP address and port provided. 
        Object creates a new thread where each new connection will respond to
        &#34;&#34;&#34;
        try:
            
            self.socket.connect( (self.ip_address, self._DEFAULT_PORT) )
            self._is_connected = True
            self.thread = Thread(target = self.handle_connection, args=())
            self.thread.start()
            if self.thread:
                self.thread.join()

        except ConnectionRefusedError:
            #Implement timeout or repetition
            print(&#34;Unable to connect to server, try again&#34;)
        except KeyboardInterrupt:
            self.socket.close()
            self._is_connected = False
        except Exception:
            return

    
    def handle_connection(self):
        &#34;&#34;&#34;
        Internal function which handles all single client-server communication
        Method is responsible for parsing any incoming and outgoing message sent through the TCP socket
        &#34;&#34;&#34;
        lcls = locals()
        cmd_format : RequestType or None = None
        while self._is_connected:
            try:
                msg = self.cin()
                if len(msg):
                    try:
                        exec(&#34;cmd_format_lcls = RequestType.%s&#34; % msg[0].upper(), globals(), lcls)
                        cmd_format = lcls[&#34;cmd_format_lcls&#34;]
                        for x in self.create_message_functions:
                            if(x[0] == cmd_format):
                                self.socket.send( x[1](msg, cmd_format) )
                    except (AttributeError ,SyntaxError, IndexError) as e:
                        # print(&#34;Invalid message:&#34;, e)
                        # self.socket.send not necessary as the client application should be aware of the supported commands (eg. offline)
                        if msg[0] == &#34;bye&#34;:
                            raise KeyboardInterrupt()

                        self.socket.send(
                            &#34; &#34;.join(msg).encode(&#34;utf-8&#34;)
                        )
                    except OSError as e:
                        print(&#34;OS Error occured: &#34;,e)
                        return
                    except ValueError as e:
                        print(e)
                        continue

                    recv = self.socket.recv(self._MAX_BUFFER)
                    
                    if recv:
                        res = self.check_response(recv)
                        if type(res.type) is ResponseType:
                            for x in self.on_response_functions:
                                if res.type == x[0]:
                                    x[1](res)
                        else:
                            self._is_connected = False
                    else:
                        self._is_connected = False

            except (KeyboardInterrupt, OSError):
                return

    def check_response(self, data : bytes) -&gt; Message:
        &#34;&#34;&#34;
        Deserialize the incoming message

        Parameters
        ---
        data: bytes
            Byte object received by the socket
        
        Returns
        ---
        Deserialized message object
        &#34;&#34;&#34;
        return Util.deserialize(data, MessageType.RESPONSE)


    def on_send(self, *args: Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is sent

        Parameters
        ---
        *args: List[Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.create_message_functions.append(x)

    def on_response(self, *args: Tuple[MethodType,  Callable[[Message], None ]] ):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is received

        Parameters
        ---
        *args: List[Tuple[MethodType,  Callable[[Message], None ]]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.on_response_functions.append(x)


    def cin(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Reads stdin from command-line. By default prints &#39;ftp&gt;&#39; before reading input
        &#34;&#34;&#34;
        try:
            msg = input(&#34;ftp&gt; &#34;)
            return msg.strip().split()
        except EOFError:
            raise KeyboardInterrupt



    def handler(self, signum , frame):
        &#34;&#34;&#34;
        Internal funtion used to define a signal handler that is called when a SIGINT signal is raised by this process
        &#34;&#34;&#34;
        
        #stdin is locking. Hence after SIGINT the application will still hang
        #probable solution would be implementing the thread as daemon

        print(&#34;\nClosing FTP Connection. Press [ENTER] to finish&#34;)
        self._is_connected = False
        self.socket.close()
        
        # sys.stdin.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ftp.tcp.client.TcpClient"><code class="flex name class">
<span>class <span class="ident">TcpClient</span></span>
<span>(</span><span>ip_addr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>TCP Client interface that creates a new socket given the ip address provided for FTP communication</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ip_addr</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>&nbsp;</p>
<p>IP address which the TCP service would be listening to
-p: int
port value which socket will bind its connection
-a: str
new IP address that TCP service will be using</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TcpClient():
    _DEFAULT_PORT = 1025
    _MAX_BUFFER = 512

    def __init__(self, ip_addr, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        TCP Client interface that creates a new socket given the ip address provided for FTP communication

        Parameters
        ---
        ip_addr: str
            IP address which the TCP service would be listening to
        -p: int
            port value which socket will bind its connection
        -a: str
            new IP address that TCP service will be using
        
        &#34;&#34;&#34;
        self.thread = None
        self.socket = sok.socket(sok.AF_INET, sok.SOCK_STREAM)
        for k,v in kwargs.items():
            if &#34;-p&#34; in k:
                self._DEFAULT_PORT = int(v)
            elif &#34;-a&#34; in k:
                ip_addr = v
        self.ip_address = ip_addr
        self._is_connected = False
        self.create_message_functions : List[Tuple[MethodType, FunctionType] ] = []
        self.on_response_functions: List[Tuple[MethodType, FunctionType]] = []

        signal.signal(signal.SIGINT, self.handler)


    def connect(self):
        &#34;&#34;&#34;
        Creates a TCP socket bounded to the given IP address and port provided. 
        Object creates a new thread where each new connection will respond to
        &#34;&#34;&#34;
        try:
            
            self.socket.connect( (self.ip_address, self._DEFAULT_PORT) )
            self._is_connected = True
            self.thread = Thread(target = self.handle_connection, args=())
            self.thread.start()
            if self.thread:
                self.thread.join()

        except ConnectionRefusedError:
            #Implement timeout or repetition
            print(&#34;Unable to connect to server, try again&#34;)
        except KeyboardInterrupt:
            self.socket.close()
            self._is_connected = False
        except Exception:
            return

    
    def handle_connection(self):
        &#34;&#34;&#34;
        Internal function which handles all single client-server communication
        Method is responsible for parsing any incoming and outgoing message sent through the TCP socket
        &#34;&#34;&#34;
        lcls = locals()
        cmd_format : RequestType or None = None
        while self._is_connected:
            try:
                msg = self.cin()
                if len(msg):
                    try:
                        exec(&#34;cmd_format_lcls = RequestType.%s&#34; % msg[0].upper(), globals(), lcls)
                        cmd_format = lcls[&#34;cmd_format_lcls&#34;]
                        for x in self.create_message_functions:
                            if(x[0] == cmd_format):
                                self.socket.send( x[1](msg, cmd_format) )
                    except (AttributeError ,SyntaxError, IndexError) as e:
                        # print(&#34;Invalid message:&#34;, e)
                        # self.socket.send not necessary as the client application should be aware of the supported commands (eg. offline)
                        if msg[0] == &#34;bye&#34;:
                            raise KeyboardInterrupt()

                        self.socket.send(
                            &#34; &#34;.join(msg).encode(&#34;utf-8&#34;)
                        )
                    except OSError as e:
                        print(&#34;OS Error occured: &#34;,e)
                        return
                    except ValueError as e:
                        print(e)
                        continue

                    recv = self.socket.recv(self._MAX_BUFFER)
                    
                    if recv:
                        res = self.check_response(recv)
                        if type(res.type) is ResponseType:
                            for x in self.on_response_functions:
                                if res.type == x[0]:
                                    x[1](res)
                        else:
                            self._is_connected = False
                    else:
                        self._is_connected = False

            except (KeyboardInterrupt, OSError):
                return

    def check_response(self, data : bytes) -&gt; Message:
        &#34;&#34;&#34;
        Deserialize the incoming message

        Parameters
        ---
        data: bytes
            Byte object received by the socket
        
        Returns
        ---
        Deserialized message object
        &#34;&#34;&#34;
        return Util.deserialize(data, MessageType.RESPONSE)


    def on_send(self, *args: Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is sent

        Parameters
        ---
        *args: List[Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.create_message_functions.append(x)

    def on_response(self, *args: Tuple[MethodType,  Callable[[Message], None ]] ):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is received

        Parameters
        ---
        *args: List[Tuple[MethodType,  Callable[[Message], None ]]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.on_response_functions.append(x)


    def cin(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Reads stdin from command-line. By default prints &#39;ftp&gt;&#39; before reading input
        &#34;&#34;&#34;
        try:
            msg = input(&#34;ftp&gt; &#34;)
            return msg.strip().split()
        except EOFError:
            raise KeyboardInterrupt



    def handler(self, signum , frame):
        &#34;&#34;&#34;
        Internal funtion used to define a signal handler that is called when a SIGINT signal is raised by this process
        &#34;&#34;&#34;
        
        #stdin is locking. Hence after SIGINT the application will still hang
        #probable solution would be implementing the thread as daemon

        print(&#34;\nClosing FTP Connection. Press [ENTER] to finish&#34;)
        self._is_connected = False
        self.socket.close()
        
        # sys.stdin.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ftp.tcp.client.TcpClient.check_response"><code class="name flex">
<span>def <span class="ident">check_response</span></span>(<span>self, data: bytes) ‑> <a title="ftp.parser.message.Message" href="../parser/message.html#ftp.parser.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize the incoming message</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Byte object received by the socket</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Deserialized message object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_response(self, data : bytes) -&gt; Message:
    &#34;&#34;&#34;
    Deserialize the incoming message

    Parameters
    ---
    data: bytes
        Byte object received by the socket
    
    Returns
    ---
    Deserialized message object
    &#34;&#34;&#34;
    return Util.deserialize(data, MessageType.RESPONSE)</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.cin"><code class="name flex">
<span>def <span class="ident">cin</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads stdin from command-line. By default prints 'ftp&gt;' before reading input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cin(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Reads stdin from command-line. By default prints &#39;ftp&gt;&#39; before reading input
    &#34;&#34;&#34;
    try:
        msg = input(&#34;ftp&gt; &#34;)
        return msg.strip().split()
    except EOFError:
        raise KeyboardInterrupt</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TCP socket bounded to the given IP address and port provided.
Object creates a new thread where each new connection will respond to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;
    Creates a TCP socket bounded to the given IP address and port provided. 
    Object creates a new thread where each new connection will respond to
    &#34;&#34;&#34;
    try:
        
        self.socket.connect( (self.ip_address, self._DEFAULT_PORT) )
        self._is_connected = True
        self.thread = Thread(target = self.handle_connection, args=())
        self.thread.start()
        if self.thread:
            self.thread.join()

    except ConnectionRefusedError:
        #Implement timeout or repetition
        print(&#34;Unable to connect to server, try again&#34;)
    except KeyboardInterrupt:
        self.socket.close()
        self._is_connected = False
    except Exception:
        return</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.handle_connection"><code class="name flex">
<span>def <span class="ident">handle_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal function which handles all single client-server communication
Method is responsible for parsing any incoming and outgoing message sent through the TCP socket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_connection(self):
    &#34;&#34;&#34;
    Internal function which handles all single client-server communication
    Method is responsible for parsing any incoming and outgoing message sent through the TCP socket
    &#34;&#34;&#34;
    lcls = locals()
    cmd_format : RequestType or None = None
    while self._is_connected:
        try:
            msg = self.cin()
            if len(msg):
                try:
                    exec(&#34;cmd_format_lcls = RequestType.%s&#34; % msg[0].upper(), globals(), lcls)
                    cmd_format = lcls[&#34;cmd_format_lcls&#34;]
                    for x in self.create_message_functions:
                        if(x[0] == cmd_format):
                            self.socket.send( x[1](msg, cmd_format) )
                except (AttributeError ,SyntaxError, IndexError) as e:
                    # print(&#34;Invalid message:&#34;, e)
                    # self.socket.send not necessary as the client application should be aware of the supported commands (eg. offline)
                    if msg[0] == &#34;bye&#34;:
                        raise KeyboardInterrupt()

                    self.socket.send(
                        &#34; &#34;.join(msg).encode(&#34;utf-8&#34;)
                    )
                except OSError as e:
                    print(&#34;OS Error occured: &#34;,e)
                    return
                except ValueError as e:
                    print(e)
                    continue

                recv = self.socket.recv(self._MAX_BUFFER)
                
                if recv:
                    res = self.check_response(recv)
                    if type(res.type) is ResponseType:
                        for x in self.on_response_functions:
                            if res.type == x[0]:
                                x[1](res)
                    else:
                        self._is_connected = False
                else:
                    self._is_connected = False

        except (KeyboardInterrupt, OSError):
            return</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.handler"><code class="name flex">
<span>def <span class="ident">handler</span></span>(<span>self, signum, frame)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal funtion used to define a signal handler that is called when a SIGINT signal is raised by this process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handler(self, signum , frame):
    &#34;&#34;&#34;
    Internal funtion used to define a signal handler that is called when a SIGINT signal is raised by this process
    &#34;&#34;&#34;
    
    #stdin is locking. Hence after SIGINT the application will still hang
    #probable solution would be implementing the thread as daemon

    print(&#34;\nClosing FTP Connection. Press [ENTER] to finish&#34;)
    self._is_connected = False
    self.socket.close()
    
    # sys.stdin.close()</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.on_response"><code class="name flex">
<span>def <span class="ident">on_response</span></span>(<span>self, *args: Tuple[<a title="ftp.parser.message_type.MethodType" href="../parser/message_type.html#ftp.parser.message_type.MethodType">MethodType</a>, Callable[[<a title="ftp.parser.message.Message" href="../parser/message.html#ftp.parser.message.Message">Message</a>], None]])</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a callback that is called when a message is received</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>List[Tuple[MethodType,
Callable[[Message], None ]]]</code></dt>
<dd>List of callable objects containing its Method type and respective callback function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_response(self, *args: Tuple[MethodType,  Callable[[Message], None ]] ):
    &#34;&#34;&#34;
    Attach a callback that is called when a message is received

    Parameters
    ---
    *args: List[Tuple[MethodType,  Callable[[Message], None ]]]
        List of callable objects containing its Method type and respective callback function
    &#34;&#34;&#34;
    for x in args:
        self.on_response_functions.append(x)</code></pre>
</details>
</dd>
<dt id="ftp.tcp.client.TcpClient.on_send"><code class="name flex">
<span>def <span class="ident">on_send</span></span>(<span>self, *args: Tuple[<a title="ftp.parser.message_type.MethodType" href="../parser/message_type.html#ftp.parser.message_type.MethodType">MethodType</a>, Callable[[List[str], <a title="ftp.parser.message_type.MethodType" href="../parser/message_type.html#ftp.parser.message_type.MethodType">MethodType</a>], bytes]])</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a callback that is called when a message is sent</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>List[Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]]</code></dt>
<dd>List of callable objects containing its Method type and respective callback function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_send(self, *args: Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]):
    &#34;&#34;&#34;
    Attach a callback that is called when a message is sent

    Parameters
    ---
    *args: List[Tuple[ MethodType ,Callable[[List[str], MethodType], bytes]]]
        List of callable objects containing its Method type and respective callback function
    &#34;&#34;&#34;
    for x in args:
        self.create_message_functions.append(x)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ftp.tcp" href="index.html">ftp.tcp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ftp.tcp.client.TcpClient" href="#ftp.tcp.client.TcpClient">TcpClient</a></code></h4>
<ul class="two-column">
<li><code><a title="ftp.tcp.client.TcpClient.check_response" href="#ftp.tcp.client.TcpClient.check_response">check_response</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.cin" href="#ftp.tcp.client.TcpClient.cin">cin</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.connect" href="#ftp.tcp.client.TcpClient.connect">connect</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.handle_connection" href="#ftp.tcp.client.TcpClient.handle_connection">handle_connection</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.handler" href="#ftp.tcp.client.TcpClient.handler">handler</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.on_response" href="#ftp.tcp.client.TcpClient.on_response">on_response</a></code></li>
<li><code><a title="ftp.tcp.client.TcpClient.on_send" href="#ftp.tcp.client.TcpClient.on_send">on_send</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>