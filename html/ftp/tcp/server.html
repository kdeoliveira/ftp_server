<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ftp.tcp.server API documentation</title>
<meta name="description" content="TCP socket interface representing FTP server" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ftp.tcp.server</code></h1>
</header>
<section id="section-intro">
<p>TCP socket interface representing FTP server</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
TCP socket interface representing FTP server
&#34;&#34;&#34;

from ast import arg
import pickle
import socket as sok
import sys
from threading import Thread
from types import FunctionType
from typing import Any, Callable, List, Tuple
from bitarray import util

from ftp.parser.message import Message, Util
from ftp.parser.message_type import MessageType, RequestType, ResponseType


class TcpServer():
    _DEFAULT_PORT = 1025
    _MAX_BUFFER = 1024

    def __init__(self, ip_addr, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        TCP Server interface that creates a new socket given the ip address provided for FTP communication purposes

        Parameters
        ---
        ip_addr: str
            IP address which the TCP service would be listening to
        -p: int
            port value which socket will bind its connection
        -a: str
            new IP address that TCP service will be using
        
        &#34;&#34;&#34;
        self.thread = None
        self.socket = sok.socket(sok.AF_INET, sok.SOCK_STREAM)
        self.socket.setsockopt(sok.SOL_SOCKET, sok.SO_REUSEADDR, 1)
        for k,v in kwargs.items():
            if &#34;-p&#34; in k:
                self._DEFAULT_PORT = int(v)
            elif &#34;-a&#34; in k:
                ip_addr = v
        self.socket.bind( (ip_addr, self._DEFAULT_PORT) )
        self.ip_address = ip_addr
        self.recv_functions : List[Tuple[RequestType, FunctionType]] = []

        self.is_connected = False

    def _init_app(self) -&gt; str:
        &#34;&#34;&#34;
        Initial message printed into command-line when TCP service is initiated
        &#34;&#34;&#34;
        return &#34;&#34;&#34;-- FTP Server initializing on {ip}:{port}
-- Version 1.0.0 by Kevin de Oliveira
-- README contains a list of available commands and some concepts guiding&#34;&#34;&#34;.format(ip = self.ip_address, port = self._DEFAULT_PORT)

    def listen(self):
        &#34;&#34;&#34;
        Starts a new threded TCP service by connecting to the respective server.
        &#34;&#34;&#34;
        self.socket.listen()
        print(self._init_app())
        while True:
            try:
                conn, addr = self.socket.accept()
                self.thread = Thread(target=self.handle_listen, args=(conn, addr))
                self.is_connected = True
                self.thread.start()
                if self.thread:
                    self.thread.join()
            except KeyboardInterrupt:
                    print(&#34;Closing server&#34;)
                    self.is_connected = False
                    self.socket.close()
                    return

        

    def handle_listen(self, conn : sok.socket, addr : sok.AddressInfo):
        &#34;&#34;&#34;
        Internal function that is responsible for parsing any incoming and outgoing message sent to the TCP socket
        &#34;&#34;&#34;
        print(&#34;&#34;&#34;&gt; New connection {addr}:{port}&#34;&#34;&#34;.format(addr = addr[0], port=addr[1]))
        while self.is_connected:
            try:
                data = conn.recv(self._MAX_BUFFER)
                if not data:
                    return None
                
                out = self.parse_packet(data)
                
                for x in self.recv_functions:
                    if(x[0] == out.type):
                        conn.sendto(x[1](addr, out), addr)


            except BrokenPipeError as e:
                print(e, addr)
            except ValueError:
                message = Message(3, ResponseType.ERROR_UNKNOWN)
                message.parse(&#34;00000&#34;)
                conn.sendto( Util.serialize(message) , addr )
            except KeyboardInterrupt:
                return

    def on_receive(self, *args : Callable[[sok.AddressInfo, Message], bytes]):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is received

        Parameters
        ---
        *args: List[Callable[[sok.AddressInfo, Message], bytes]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.recv_functions.append(x)

    @staticmethod
    def parse_packet(data : bytes) -&gt; Message:
        &#34;&#34;&#34;
        Deserializes incoming byte received by the TCP socket

        Parameters
        ---
        data: bytes
            Byte object received by socket

        Returns
        ---
        Message object
        &#34;&#34;&#34;
        return Util.deserialize(data, MessageType.REQUEST)

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ftp.tcp.server.TcpServer"><code class="flex name class">
<span>class <span class="ident">TcpServer</span></span>
<span>(</span><span>ip_addr, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>TCP Server interface that creates a new socket given the ip address provided for FTP communication purposes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ip_addr</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>&nbsp;</p>
<p>IP address which the TCP service would be listening to
-p: int
port value which socket will bind its connection
-a: str
new IP address that TCP service will be using</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TcpServer():
    _DEFAULT_PORT = 1025
    _MAX_BUFFER = 1024

    def __init__(self, ip_addr, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        TCP Server interface that creates a new socket given the ip address provided for FTP communication purposes

        Parameters
        ---
        ip_addr: str
            IP address which the TCP service would be listening to
        -p: int
            port value which socket will bind its connection
        -a: str
            new IP address that TCP service will be using
        
        &#34;&#34;&#34;
        self.thread = None
        self.socket = sok.socket(sok.AF_INET, sok.SOCK_STREAM)
        self.socket.setsockopt(sok.SOL_SOCKET, sok.SO_REUSEADDR, 1)
        for k,v in kwargs.items():
            if &#34;-p&#34; in k:
                self._DEFAULT_PORT = int(v)
            elif &#34;-a&#34; in k:
                ip_addr = v
        self.socket.bind( (ip_addr, self._DEFAULT_PORT) )
        self.ip_address = ip_addr
        self.recv_functions : List[Tuple[RequestType, FunctionType]] = []

        self.is_connected = False

    def _init_app(self) -&gt; str:
        &#34;&#34;&#34;
        Initial message printed into command-line when TCP service is initiated
        &#34;&#34;&#34;
        return &#34;&#34;&#34;-- FTP Server initializing on {ip}:{port}
-- Version 1.0.0 by Kevin de Oliveira
-- README contains a list of available commands and some concepts guiding&#34;&#34;&#34;.format(ip = self.ip_address, port = self._DEFAULT_PORT)

    def listen(self):
        &#34;&#34;&#34;
        Starts a new threded TCP service by connecting to the respective server.
        &#34;&#34;&#34;
        self.socket.listen()
        print(self._init_app())
        while True:
            try:
                conn, addr = self.socket.accept()
                self.thread = Thread(target=self.handle_listen, args=(conn, addr))
                self.is_connected = True
                self.thread.start()
                if self.thread:
                    self.thread.join()
            except KeyboardInterrupt:
                    print(&#34;Closing server&#34;)
                    self.is_connected = False
                    self.socket.close()
                    return

        

    def handle_listen(self, conn : sok.socket, addr : sok.AddressInfo):
        &#34;&#34;&#34;
        Internal function that is responsible for parsing any incoming and outgoing message sent to the TCP socket
        &#34;&#34;&#34;
        print(&#34;&#34;&#34;&gt; New connection {addr}:{port}&#34;&#34;&#34;.format(addr = addr[0], port=addr[1]))
        while self.is_connected:
            try:
                data = conn.recv(self._MAX_BUFFER)
                if not data:
                    return None
                
                out = self.parse_packet(data)
                
                for x in self.recv_functions:
                    if(x[0] == out.type):
                        conn.sendto(x[1](addr, out), addr)


            except BrokenPipeError as e:
                print(e, addr)
            except ValueError:
                message = Message(3, ResponseType.ERROR_UNKNOWN)
                message.parse(&#34;00000&#34;)
                conn.sendto( Util.serialize(message) , addr )
            except KeyboardInterrupt:
                return

    def on_receive(self, *args : Callable[[sok.AddressInfo, Message], bytes]):
        &#34;&#34;&#34;
        Attach a callback that is called when a message is received

        Parameters
        ---
        *args: List[Callable[[sok.AddressInfo, Message], bytes]]
            List of callable objects containing its Method type and respective callback function
        &#34;&#34;&#34;
        for x in args:
            self.recv_functions.append(x)

    @staticmethod
    def parse_packet(data : bytes) -&gt; Message:
        &#34;&#34;&#34;
        Deserializes incoming byte received by the TCP socket

        Parameters
        ---
        data: bytes
            Byte object received by socket

        Returns
        ---
        Message object
        &#34;&#34;&#34;
        return Util.deserialize(data, MessageType.REQUEST)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ftp.tcp.server.TcpServer.parse_packet"><code class="name flex">
<span>def <span class="ident">parse_packet</span></span>(<span>data: bytes) ‑> <a title="ftp.parser.message.Message" href="../parser/message.html#ftp.parser.message.Message">Message</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes incoming byte received by the TCP socket</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Byte object received by socket</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Message object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_packet(data : bytes) -&gt; Message:
    &#34;&#34;&#34;
    Deserializes incoming byte received by the TCP socket

    Parameters
    ---
    data: bytes
        Byte object received by socket

    Returns
    ---
    Message object
    &#34;&#34;&#34;
    return Util.deserialize(data, MessageType.REQUEST)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ftp.tcp.server.TcpServer.handle_listen"><code class="name flex">
<span>def <span class="ident">handle_listen</span></span>(<span>self, conn: socket.socket, addr: socket.AddressInfo)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal function that is responsible for parsing any incoming and outgoing message sent to the TCP socket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_listen(self, conn : sok.socket, addr : sok.AddressInfo):
    &#34;&#34;&#34;
    Internal function that is responsible for parsing any incoming and outgoing message sent to the TCP socket
    &#34;&#34;&#34;
    print(&#34;&#34;&#34;&gt; New connection {addr}:{port}&#34;&#34;&#34;.format(addr = addr[0], port=addr[1]))
    while self.is_connected:
        try:
            data = conn.recv(self._MAX_BUFFER)
            if not data:
                return None
            
            out = self.parse_packet(data)
            
            for x in self.recv_functions:
                if(x[0] == out.type):
                    conn.sendto(x[1](addr, out), addr)


        except BrokenPipeError as e:
            print(e, addr)
        except ValueError:
            message = Message(3, ResponseType.ERROR_UNKNOWN)
            message.parse(&#34;00000&#34;)
            conn.sendto( Util.serialize(message) , addr )
        except KeyboardInterrupt:
            return</code></pre>
</details>
</dd>
<dt id="ftp.tcp.server.TcpServer.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a new threded TCP service by connecting to the respective server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen(self):
    &#34;&#34;&#34;
    Starts a new threded TCP service by connecting to the respective server.
    &#34;&#34;&#34;
    self.socket.listen()
    print(self._init_app())
    while True:
        try:
            conn, addr = self.socket.accept()
            self.thread = Thread(target=self.handle_listen, args=(conn, addr))
            self.is_connected = True
            self.thread.start()
            if self.thread:
                self.thread.join()
        except KeyboardInterrupt:
                print(&#34;Closing server&#34;)
                self.is_connected = False
                self.socket.close()
                return</code></pre>
</details>
</dd>
<dt id="ftp.tcp.server.TcpServer.on_receive"><code class="name flex">
<span>def <span class="ident">on_receive</span></span>(<span>self, *args: Callable[[socket.AddressInfo, <a title="ftp.parser.message.Message" href="../parser/message.html#ftp.parser.message.Message">Message</a>], bytes])</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a callback that is called when a message is received</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>List[Callable[[sok.AddressInfo, Message], bytes]]</code></dt>
<dd>List of callable objects containing its Method type and respective callback function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive(self, *args : Callable[[sok.AddressInfo, Message], bytes]):
    &#34;&#34;&#34;
    Attach a callback that is called when a message is received

    Parameters
    ---
    *args: List[Callable[[sok.AddressInfo, Message], bytes]]
        List of callable objects containing its Method type and respective callback function
    &#34;&#34;&#34;
    for x in args:
        self.recv_functions.append(x)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ftp.tcp" href="index.html">ftp.tcp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ftp.tcp.server.TcpServer" href="#ftp.tcp.server.TcpServer">TcpServer</a></code></h4>
<ul class="">
<li><code><a title="ftp.tcp.server.TcpServer.handle_listen" href="#ftp.tcp.server.TcpServer.handle_listen">handle_listen</a></code></li>
<li><code><a title="ftp.tcp.server.TcpServer.listen" href="#ftp.tcp.server.TcpServer.listen">listen</a></code></li>
<li><code><a title="ftp.tcp.server.TcpServer.on_receive" href="#ftp.tcp.server.TcpServer.on_receive">on_receive</a></code></li>
<li><code><a title="ftp.tcp.server.TcpServer.parse_packet" href="#ftp.tcp.server.TcpServer.parse_packet">parse_packet</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>